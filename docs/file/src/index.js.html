<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/index.js | json-csv-transformer</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="transform json to csv, and vice versa"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="json-csv-transformer"><meta property="twitter:description" content="transform json to csv, and vice versa"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/kagawagao/json-csv-transformer"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~CSV.html">CSV</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// @flow
import jschardet from &apos;jschardet&apos;
import iconv from &apos;iconv-lite&apos;

// skip iconv warning
iconv.skipDecodeWarning = true

/**
 * @desc CSV
 * @export
 * @class CSV
 */
export default class CSV {
  /**
   * @desc schema
   * @type {Array&lt;Schema&gt;}
   * @memberof CSV
   */
  schema: Array&lt;Schema&gt;;
  /**
   * @desc data buffer
   * @type {?Buffer}
   * @memberof CSV
   */
  buffer: ?Buffer;
  /**
   * @desc encoding
   * @type {string}
   * @memberof CSV
   */
  encoding: string;
  /**
   * @desc csv data string
   * @type {?string}
   * @memberof CSV
   */
  data: string;
  /**
   * @desc generate csv with header
   * @type {boolean}
   * @memberof CSV
   */
  withHeader: boolean;
  /**
   * @desc Creates an instance of CSV.
   * @param {CSVOption} option option
   * @param {Array&lt;Schema&gt;} option.schema schema
   * @param {string} [option.encoding=utf8] encoding
   * @param {boolean} [option.widthHeader=true] with header
   * @memberof CSV
   */
  constructor (option: CSVOption) {
    const { schema, encoding = &apos;utf8&apos;, withHeader = true } = option
    this.checkSchema((schema))
    this.checkEncoding(encoding)
    this.schema = schema
    this.encoding = encoding
    this.data = &apos;&apos;
    this.buffer = null
    this.withHeader = !!withHeader
  }

  /**
   * @desc check schema
   * @throws {TypeError} Invalid schema presented
   * @memberof CSV
   */
  checkSchema = (schema: Array&lt;Schema&gt;) =&gt; {
    const validSchema = schema.every(item =&gt; item.key)
    if (!validSchema) {
      throw new TypeError(&apos;Invalid schema presented&apos;)
    }
  }

  /**
   * @desc check encoding
   * @param {string} encoding
   * @throws {TypeError} Encoding Not Support
   * @memberof CSV
   */
  checkEncoding = (encoding: string): void =&gt; {
    const validEncoding = iconv.encodingExists(encoding)
    if (!validEncoding) {
      throw new TypeError(`Encoding Error: ${encoding} is not supported`)
    }
  }

  /**
   * @desc find schema by key
   * @param {string} key
   * @return {Schema} schema
   * @memberof CSV
   */
  findSchemaByKey = (key: string): Schema =&gt; {
    return this.schema.find((item) =&gt; item.key === key) || {
      key,
      type: &apos;string&apos;,
      label: key
    }
  }

  /**
   * @desc format value
   * @param {any} value
   * @param {string} key
   * @return {string|number} formated value
   * @memberof CSV
   */
  format = (value: any, key: string): string | number =&gt; {
    const schema = this.findSchemaByKey(key)
    switch (schema.type) {
      case &apos;number&apos;:
        return parseFloat(value)
      case &apos;date&apos;:
        return new Date(value).toDateString()
      case &apos;boolean&apos;:
        return (!!value).toString()
      case &apos;custom&apos;:
      case &apos;string&apos;:
      default:
        return value
    }
  }

  /**
   * @desc encode str to buffer with specific encoding
   * @param {string} str
   * @param {string} encoding
   * @return {Buffer} encoded buffer
   * @memberof CSV
   */
  encode = (str: string): Buffer =&gt; {
    this.checkEncoding(this.encoding)
    return iconv.encode(str, this.encoding)
  }

  /**
   * @desc decode buffer or string to string with specific encoding
   * @param {Buffer|string} buf
   * @param {string} encoding
   * @return {string} decoded string
   * @memberof CSV
   */
  decode = (buf: Buffer | string): string =&gt; {
    this.checkEncoding(this.encoding)
    return iconv.decode(buf, this.encoding)
  }

  /**
   * @desc convert json to csv data string
   * @param {Array&lt;Object&gt;} items
   * @param {CustomOption} option
   * @param {string} option.encoding
   * @return {string} csv data string
   * @memberof CSV
   */
  convert = (items: Array&lt;{[x: string]: any}&gt;, option?: CustomOption = {}): string =&gt; {
    this.encoding = option.encoding || &apos;utf8&apos;
    const columns = this.schema
    const csvArray = []
    const header = []
    const keys = []

    columns.forEach((column) =&gt; {
      keys.push(column.key)
      header.push(&apos;&quot;&apos; + (column.label || column.key) + &apos;&quot;&apos;)
    })

    if (this.withHeader) {
      csvArray.push(header)
    }

    items.forEach((item) =&gt; {
      csvArray.push(keys.map((key) =&gt; &apos;&quot;&apos; + this.format(item[key], key) + &apos;&quot;&apos;).join(&apos;,&apos;))
    })

    const str = csvArray.join(&apos;\n&apos;)

    this.buffer = this.encode(str)
    this.data = this.decode(this.buffer)
    return this.data
  }

  /**
   * @desc parse buffer or string to csv data string
   * @param {Buffer|string} buf
   * @param {CustomOption} option
   * @param {string} option.encoding
   * @return {string} parsed csv data string
   * @memberof CSV
   */
  parse = (buf: Buffer, option?: CustomOption = {}): string =&gt; {
    if (Array.isArray(buf)) {
      this.data = this.convert(buf, option)
    } else {
      try {
        const res = jschardet.detect(buf)
        this.encoding = res.encoding
        this.data = this.decode(buf)
      } catch (error) {
        throw new Error(&apos;Parse failed, please check input data&apos;)
      }
    }
    return this.data
  }

  /**
   * @desc get file dataURL
   * @return {string} dataURL
   * @memberof CSV
   */
  getDataURL = (): string =&gt; {
    return this.buffer ? `data:text/csv;base64,${this.buffer.toString(&apos;base64&apos;)}` : &apos;&apos;
  }

  /**
   * @desc transform parsed data to json
   * @return {Array&lt;Object&gt;} json
   * @memberof CSV
   */
  toJSON = (): Array&lt;{[x: string]: any}&gt; =&gt; {
    const columns = this.schema
    if (!this.data) {
      return []
    } else {
      const data = this.data.replace(/\\r\\n|\\r/g, &apos;\n&apos;).replace(/;|\\t|\|\^/g, &apos;,&apos;)
      let temp = data.split(&apos;\n&apos;)
      // TODO: header check
      temp.shift()
      // remove empty line
      temp = temp.filter(temp =&gt; temp)
      temp = temp.map((str: string) =&gt; {
        const item = {}
        const arr = str.split(&apos;,&apos;)
        arr.map((s, index) =&gt; {
          s = s.substring(1, s.length - 1)
          const column = columns[index]
          switch (column.type) {
            case &apos;number&apos;:
              item[column.key] = parseFloat(s)
              break
            case &apos;boolean&apos;:
              let val
              if (s === &apos;true&apos;) {
                val = true
              } else if (s === &apos;false&apos;) {
                val = false
              } else {
                val = !!s
              }
              item[column.key] = val
              break
            case &apos;date&apos;:
              item[column.key] = new Date(s)
              break
            case &apos;string&apos;:
            case &apos;custom&apos;:
            default:
              item[column.key] = s
          }
        })
        return item
      })
      return temp
    }
  }

  /**
   * @desc to string
   * @return {string} csv data string
   * @memberof CSV
   */
  toString = (): string =&gt; {
    return this.data
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc2.org">esdoc2<span data-ice="esdocVersion">(2.1.3)</span><img src="./image/esdoc2-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
